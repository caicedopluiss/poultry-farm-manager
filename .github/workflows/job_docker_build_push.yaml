name: Docker Build and Push

on:
    workflow_call:
        inputs:
            dockerfile:
                description: "Dockerfile to use for building the image"
                required: false
                type: string
                default: "Dockerfile.standalone"
            build_args:
                description: "Build arguments for Docker build i.e --build-arg KEY=VALUE"
                required: false
                type: string
                default: ""
            release_tag:
                description: "Release tag (e.g., v1.0.0)"
                required: true
                type: string
            full_image_name:
                description: "Docker full image name (i.e. registry/org/image_name)"
                required: true
                type: string
            clean_registry:
                description: "Clean untagged images from registry"
                required: false
                type: boolean
                default: false
        secrets:
            DIGITALOCEAN_ACCESS_TOKEN:
                description: "DigitalOcean access token"
                required: true
        outputs:
            image_tag:
                description: "Generated image tag"
                value: ${{ jobs.docker-build-push.outputs.image_tag }}

jobs:
    docker-build-push:
        runs-on: ubuntu-latest
        outputs:
            image_tag: ${{ steps.build.outputs.image_tag }}
        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Install doctl
              uses: digitalocean/action-doctl@v2
              with:
                  token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

            - name: Login to DigitalOcean Container Registry
              run: doctl registry login

            - name: Build and tag Docker image
              id: build
              run: |
                  SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-8)
                  RELEASE_TAG="${{ inputs.release_tag }}"
                  DOCKERFILE="${{ inputs.dockerfile }}"
                  BUILD_ARGS="${{ inputs.build_args }}"

                  echo "Building image with tags: $RELEASE_TAG, $SHORT_SHA, latest"
                  echo "Using Dockerfile: $DOCKERFILE"

                  BUILD_CMD="docker build -f $DOCKERFILE"

                  # Add build args if provided
                  if [ -n "$BUILD_ARGS" ]; then
                      BUILD_CMD="$BUILD_CMD $BUILD_ARGS"
                  fi

                  # Add tags
                  BUILD_CMD="$BUILD_CMD \
                    -t ${{ inputs.full_image_name }}:$RELEASE_TAG \
                    -t ${{ inputs.full_image_name }}:$SHORT_SHA \
                    -t ${{ inputs.full_image_name }}:latest \
                    ."

                  echo "Running: $BUILD_CMD"
                  eval $BUILD_CMD

                  echo "image_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT

            - name: Push images to registry
              run: |
                  SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-8)
                  RELEASE_TAG="${{ inputs.release_tag }}"

                  echo "Pushing images..."
                  docker push ${{ inputs.full_image_name }}:$RELEASE_TAG
                  docker push ${{ inputs.full_image_name }}:$SHORT_SHA
                  docker push ${{ inputs.full_image_name }}:latest

            - name: Clean untagged images from registry
              if: ${{ inputs.clean_registry }}
              run: |
                  echo "Starting garbage collection..."
                  doctl registry garbage-collection start --include-untagged-manifests --force || echo "Garbage collection failed or already running"
