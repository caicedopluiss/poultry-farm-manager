name: Deploy Workflow

on:
    workflow_dispatch:
        inputs:
            action:
                description: "Select the deployment action"
                required: true
                default: "deploy"
                type: choice
                options:
                    - deploy # Deploy infrastructure and application
                    - destroy # Destroy infrastructure
            clean_registry:
                description: "Clean untagged images from the registry"
                required: false
                type: boolean
                default: false
            force_replace_resources:
                description: "Force replace resources (newline-separated, e.g., digitalocean_app.platform)"
                required: false
                type: string
                default: ""

jobs:
    check-context:
        runs-on: ubuntu-latest
        outputs:
            can_proceed: ${{ steps.check.outputs.can_proceed }}
            current_tag: ${{ steps.check.outputs.current_tag }}
            action_type: ${{ steps.check.outputs.action_type }}
        steps:
            - name: Check tag branch context
              id: check
              run: |
                  REF_TYPE="${{ github.ref_type }}"
                  BRANCH_NAME="${{ github.ref_name }}"
                  ACTION="${{ github.event.inputs.action }}"

                  echo "ðŸ” GitHub Context:"
                  echo "  Ref Type: $REF_TYPE"
                  echo "  Ref Name: $BRANCH_NAME"
                  echo "  Action: $ACTION"

                  # Verify we're on a tag branch
                  if [[ "$REF_TYPE" != "tag" ]]; then
                      echo "âŒ This workflow can only run on tag branches"
                      echo "Current ref type: $REF_TYPE (expected: 'tag')"
                      echo "can_proceed=false" >> $GITHUB_OUTPUT
                      exit 1
                  fi

                  echo "âœ… Running on tag branch: $BRANCH_NAME"
                  echo "can_proceed=true" >> $GITHUB_OUTPUT
                  echo "current_tag=$BRANCH_NAME" >> $GITHUB_OUTPUT
                  echo "action_type=$ACTION" >> $GITHUB_OUTPUT

    tf-destroy-application:
        uses: ./.github/workflows/job_terraform_infrastructure.yaml
        needs: check-context
        if: |
            needs.check-context.outputs.can_proceed == 'true' &&
            needs.check-context.outputs.action_type == 'destroy'
        with:
            terraform_action: "destroy"
            working_directory: "IaC/application"
            env_vars: |
                TF_VAR_image_name=${{ vars.IMAGE_NAME }}
                TF_VAR_image_tag=${{ github.ref_name }}
                TF_VAR_api_base_path=${{ vars.API_HOST_URL_PROD }}
                TF_VAR_env=Production
        secrets:
            DIGITALOCEAN_ACCESS_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
            TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}

    tf-destroy-cloud:
        uses: ./.github/workflows/job_terraform_infrastructure.yaml
        needs: tf-destroy-application
        if: |
            needs.tf-destroy-application.result == 'success'
        with:
            terraform_action: "destroy"
            working_directory: "IaC/cloud"
        secrets:
            DIGITALOCEAN_ACCESS_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
            TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}

    tf-apply-cloud:
        uses: ./.github/workflows/job_terraform_infrastructure.yaml
        needs: check-context
        if: |
            needs.check-context.outputs.can_proceed == 'true' &&
            needs.check-context.outputs.action_type == 'deploy'
        with:
            terraform_action: "apply"
            working_directory: "IaC/cloud"
            output_names: |
                registry_endpoint
        secrets:
            DIGITALOCEAN_ACCESS_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
            TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}

    get-tf-cloud-outputs:
        runs-on: ubuntu-latest
        needs: tf-apply-cloud
        if: |
            needs.tf-apply-cloud.result == 'success'
        outputs:
            registry_endpoint: ${{ steps.extract.outputs.registry_endpoint }}
        steps:
            - name: Extract cloud infrastructure outputs
              id: extract
              run: |
                  EXTRACTED_OUTPUTS="${{ needs.tf-apply-cloud.outputs.extracted_outputs }}"

                  # Extract registry_endpoint output value from the name=value format
                  REGISTRY_ENDPOINT=$(echo "$EXTRACTED_OUTPUTS" | grep "^registry_endpoint=" | cut -d'=' -f2-)

                  # Set outputs
                  echo "registry_endpoint=$REGISTRY_ENDPOINT" >> $GITHUB_OUTPUT
                  echo "âœ… Extracted registry endpoint: $REGISTRY_ENDPOINT"

    docker-build-push:
        uses: ./.github/workflows/job_docker_build_push.yaml
        needs: get-tf-cloud-outputs
        if: |
            needs.get-tf-cloud-outputs.result == 'success'
        with:
            dockerfile: "Dockerfile.standalone"
            release_tag: ${{ github.ref_name }}
            full_image_name: ${{ needs.get-tf-cloud-outputs.outputs.registry_endpoint }}/${{ vars.IMAGE_NAME }}
            clean_registry: ${{ github.event.inputs.clean_registry == 'true' }}
        secrets:
            DIGITALOCEAN_ACCESS_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

    tf-apply-application:
        uses: ./.github/workflows/job_terraform_infrastructure.yaml
        needs: docker-build-push
        if: |
            needs.docker-build-push.result == 'success'
        with:
            terraform_action: "apply"
            working_directory: "IaC/application"
            output_names: |
                webapp_url
            env_vars: |
                TF_VAR_image_name=${{ vars.IMAGE_NAME }}
                TF_VAR_image_tag=${{ github.ref_name }}
                TF_VAR_api_base_path=${{ vars.API_HOST_URL_PROD }}
                TF_VAR_env=Production
            force_replace_resources: ${{ github.event.inputs.force_replace_resources }}
        secrets:
            DIGITALOCEAN_ACCESS_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
            TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}

    get-tf-application-outputs:
        runs-on: ubuntu-latest
        needs: tf-apply-application
        if: |
            needs.tf-apply-application.result == 'success'
        outputs:
            webapp_url: ${{ steps.extract.outputs.webapp_url }}
        steps:
            - name: Extract webapp_url
              id: extract
              run: |
                  EXTRACTED_OUTPUTS="${{ needs.tf-apply-application.outputs.extracted_outputs }}"

                  # Extract webapp_url value from the name=value format
                  WEBAPP_URL=$(echo "$EXTRACTED_OUTPUTS" | grep "^webapp_url=" | cut -d'=' -f2-)

                  echo "webapp_url=$WEBAPP_URL" >> $GITHUB_OUTPUT
                  echo "âœ… Extracted webapp URL: $WEBAPP_URL"

    update-release:
        runs-on: ubuntu-latest
        needs: get-tf-application-outputs
        if: |
            needs.get-tf-application-outputs.result == 'success'
        permissions:
            contents: write
        steps:
            - name: Update GitHub Release
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  TAG_NAME="${{ github.ref_name }}"
                  WEBAPP_URL="${{ needs.get-tf-application-outputs.outputs.webapp_url }}"
                  echo "Updating GitHub Release for tag: $TAG_NAME"

                  if ! gh release view "$TAG_NAME" --repo "$GITHUB_REPOSITORY" >/dev/null 2>&1; then
                      echo "âŒ Release for tag $TAG_NAME not found!"
                  else
                      echo "âœ… Found release for tag: $TAG_NAME"
                      gh release view "$TAG_NAME" --repo "$GITHUB_REPOSITORY" > release_info.txt
                      cat release_info.txt
                      echo "Updating release notes..."
                      PREVIOUS_NOTES=$(sed '1,9d' release_info.txt)
                      echo "Previous notes:"
                      echo "$PREVIOUS_NOTES"
                      NEW_NOTES="
                    #### Deployment Date & Time (UTC): $(date -u +"%Y-%m-%dT%H:%M:%SZ")
                    #### Live URL: ${WEBAPP_URL}

                    $PREVIOUS_NOTES
                    "
                      echo "$NEW_NOTES"
                      gh release edit "$TAG_NAME" --repo "$GITHUB_REPOSITORY" \
                        --notes "$NEW_NOTES"
                    echo "âœ… GitHub Release updated with webapp URL: $WEBAPP_URL"
                    echo "**Release Published**: $TAG_NAME is now live at $WEBAPP_URL" >> $GITHUB_STEP_SUMMARY
                  fi
